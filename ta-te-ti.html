<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ta‑Te‑Ti Deluxe</title>
    <link href="https://fonts.googleapis.com/css2?family=Bubblegum+Sans&display=swap" rel="stylesheet" />
    <style>
        :root {
            --pink-light: #ffc0cb;
            --pink: #ff69b4;
            --pink-dark: #ff1493;
            --pink-extra: #ffe4e1;
            --border-radius: 12px;
        }
        * { box-sizing: border-box; }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 0.8rem; /* Adjusted gap slightly */
            min-height: 100vh;
            margin: 0;
            background: var(--pink-light);
            font-family: "Bubblegum Sans", cursive;
            color: var(--pink);
            overflow-x: hidden;
            transition: background-color 0.5s;
        }
        h1 {
            margin: 0.2em 0 0;
            font-size: 3rem;
            text-shadow: 2px 2px rgba(0,0,0,0.1);
            animation: bounce 2s infinite alternate;
        }
        @keyframes bounce {
            0% { transform: translateY(0); }
            100% { transform: translateY(-10px); }
        }
        #status {
            font-size: 1.6rem;
            min-height: 2.2rem;
            text-align: center;
            transition: transform 0.3s;
        }
        #status.highlight {
            transform: scale(1.2);
            color: var(--pink-dark);
        }
        #game {
            display: grid;
            grid-template-columns: repeat(3, 90px);
            grid-template-rows: repeat(3, 90px);
            gap: 8px;
            padding: 10px;
            border: 6px solid var(--pink);
            background: #fff;
            border-radius: var(--border-radius);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
            user-select: none;
            transition: transform 0.3s ease;
        }
        #game:hover {
            transform: scale(1.02);
        }
        .cell {
            width: 90px; height: 90px;
            display: flex; justify-content: center; align-items: center;
            font-size: 3.2rem;
            background: var(--pink-extra);
            border: 2px solid #ffb6c1;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            position: relative;
            overflow: hidden;
        }
        .cell:hover:not(.disabled) { /* Only apply hover effects if not disabled */
            background: var(--pink-light);
            transform: translateY(-3px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
        }
        .cell.disabled {
            cursor: default;
            /* Optionally, slightly different style for disabled cells */
            /* opacity: 0.7; */
        }
        .cell span {
            display: inline-block;
            transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }
        .cell.mark-animation span {
            transform: scale(1.3);
        }
        .cell.rainbow::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet, red);
            background-size: 400% 400%;
            animation: rainbowBG 2s linear infinite;
            z-index: 0;
            opacity: 0.7;
        }
        .cell.rainbow > span {
            position: relative;
            z-index: 1;
            text-shadow: 0 0 5px white;
        }
        @keyframes rainbowBG {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }
        .confetti {
            position: fixed;
            top: -10px;
            width: 8px;
            height: 12px;
            background: red;
            opacity: 0.9;
            border-radius: 2px;
            pointer-events: none;
            animation: fall 3s linear forwards;
        }
        @keyframes fall {
            to {
                transform: translateY(110vh) rotateZ(360deg);
                opacity: 0;
            }
        }
        .controls-group { /* Wrapper for control sections */
            display: flex;
            flex-direction: column;
            gap: 8px; /* Spacing between control groups like mode, difficulty, etc. */
            align-items: center; /* This will center the .game-start-options div if its width is not 100% */
            width: 100%; /* Make the group take full width to center its content lines */
            padding: 0 10px; /* Add some padding so content doesn't touch edges */
        }
        .mode, .difficulty, .game-start-options, .controls {
            display: flex;
            flex-wrap: wrap; /* Allows items to wrap if not enough space */
            gap: 10px;
            justify-content: center; /* Center the items within this flex container */
            align-items: center; /* Vertically align items in the line */
            width: 100%; /* Make each control line take full width to allow its content to be centered */
        }
         .game-start-options span { /* The "Quién empieza:" label */
            font-size: 1rem;
            margin-right: 8px; /* Add a little space between the label and the first button */
            white-space: nowrap; /* Prevent the label from wrapping */
        }
        button {
            padding: 10px 22px;
            font-size: 1rem;
            background: var(--pink);
            color: #fff;
            border: none;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.2s;
            font-family: "Bubblegum Sans", cursive;
        }
        button:hover { background: var(--pink-dark); transform: translateY(-2px); }
        button:active { transform: translateY(0); box-shadow: 0 1px 3px rgba(0,0,0,0.2); }

        button.mode-btn.active,
        button.difficulty-btn.active,
        button.start-option-btn.active { /* Combined active styles */
            outline: 3px solid var(--pink-dark);
            background: var(--pink-dark);
        }
        #results {
            font-size: 1.2rem;
            text-align: center;
            margin-top: 10px;
            background: white;
            padding: 8px 15px;
            border-radius: var(--border-radius);
            border: 2px dashed var(--pink);
        }
        #results span {
            display: inline-block;
            min-width: 2ch;
            font-weight: bold;
        }
        .theme-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5rem;
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
        }
        body.dark-theme {
            background: #2b2b2b;
            color: #ffc0cb;
        }
        body.dark-theme #game {
            border-color: var(--pink-dark);
            background: #3d3d3d;
        }
        body.dark-theme .cell {
            background: #4a4a4a;
            border-color: #5a5a5a;
            color: white;
        }
        body.dark-theme .cell:hover:not(.disabled) {
            background: #5a5a5a;
        }
        body.dark-theme #results {
            background: #3d3d3d;
            border-color: var(--pink-dark);
            color: white;
        }
        body.dark-theme .game-start-options span {
            color: var(--pink-light);
        }
        .sound-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 1.5rem;
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
        }
        @media (max-width: 480px) { /* Slightly adjusted breakpoint */
            body { gap: 0.5rem; }
            h1 { font-size: 2.5rem; }
            #game {
                grid-template-columns: repeat(3, 70px);
                grid-template-rows: repeat(3, 70px);
                gap: 5px;
            }
            .cell {
                width: 70px; height: 70px;
                font-size: 2.5rem;
            }
            button { padding: 8px 15px; font-size: 0.9rem;}
            .controls-group {
                 padding: 0 5px; /* Reduce padding slightly on small screens */
            }
            .mode, .difficulty, .game-start-options, .controls {
                 gap: 8px;
            }
            .game-start-options span {
                 /* On very small screens, if label still causes awkward wrapping with buttons,
                    you could make it display block and center text, then buttons wrap below.
                    Example:
                    display: block;
                    width: 100%;
                    text-align: center;
                    margin-bottom: 5px;
                    margin-right: 0;
                 */
            }
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="themeToggle" aria-label="Cambiar tema">🌙</button>
    <button class="sound-toggle" id="soundToggle" aria-label="Activar/Desactivar sonido">🔊</button>

    <h1>Ta‑Te‑Ti</h1>
    <div id="status" aria-live="polite">Turno del 🦄 Unicornio</div>
    <div id="game" role="grid" aria-label="Tablero de juego">
        <div class="cell" role="button" aria-label="Celda 1" data-index="0"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 2" data-index="1"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 3" data-index="2"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 4" data-index="3"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 5" data-index="4"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 6" data-index="5"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 7" data-index="6"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 8" data-index="7"><span></span></div>
        <div class="cell" role="button" aria-label="Celda 9" data-index="8"><span></span></div>
    </div>

    <div class="controls-group">
        <div class="mode" aria-label="Seleccionar modo">
            <button id="pvpBtn" class="mode-btn active">Jugador vs Jugador</button>
            <button id="cpuBtn" class="mode-btn">Jugador vs CPU</button>
        </div>
        <div class="difficulty" aria-label="Seleccionar dificultad" style="display: none;">
            <button id="easyBtn" class="difficulty-btn">Fácil</button>
            <button id="mediumBtn" class="difficulty-btn active">Normal</button>
            <button id="hardBtn" class="difficulty-btn">Difícil</button>
        </div>
        <div class="game-start-options" aria-label="Seleccionar quién empieza">
            <span>Quién empieza:</span>
            <button id="player1StartsBtn" class="start-option-btn">Jugador 1</button>
            <button id="randomStartsBtn" class="start-option-btn">Aleatorio</button>
            <button id="loserStartsBtn" class="start-option-btn">Perdedor</button>
        </div>
        <div class="controls">
            <button id="restartBtn">Reiniciar</button>
            <button id="changeSymbolsBtn">Cambiar símbolos</button>
        </div>
    </div>

    <div id="results">
        🦄 <span id="unicornWins">0</span> – ❤️ <span id="heartWins">0</span> – 🤝 <span id="draws">0</span>
    </div>
<script>
document.addEventListener('DOMContentLoaded', () => {
    // ======== State =========
    const cells = document.querySelectorAll('.cell');
    const statusDiv = document.getElementById('status');
    const restartBtn = document.getElementById('restartBtn');
    const pvpBtn = document.getElementById('pvpBtn');
    const cpuBtn = document.getElementById('cpuBtn');
    const difficultyDiv = document.querySelector('.difficulty');
    const easyBtn = document.getElementById('easyBtn');
    const mediumBtn = document.getElementById('mediumBtn');
    const hardBtn = document.getElementById('hardBtn');
    const unicornSpan = document.getElementById('unicornWins');
    const heartSpan = document.getElementById('heartWins');
    const drawsSpan = document.getElementById('draws');
    const themeToggle = document.getElementById('themeToggle');
    const soundToggle = document.getElementById('soundToggle');
    const changeSymbolsBtn = document.getElementById('changeSymbolsBtn');

    // New "Who Goes First" Buttons
    const player1StartsBtn = document.getElementById('player1StartsBtn');
    const randomStartsBtn = document.getElementById('randomStartsBtn');
    const loserStartsBtn = document.getElementById('loserStartsBtn');

    let board, currentPlayer, gameActive, vsCPU, difficulty;
    let soundEnabled = true;
    let symbolSet = [
        { player1: '🦄', player2: '❤️' },
        { player1: '🐱', player2: '🐶' },
        { player1: '🌞', player2: '🌙' },
        { player1: '❌', player2: '⭕' }
    ];
    let currentSymbolIndex = 0;
    let currentSymbols = symbolSet[currentSymbolIndex];

    let unicornWins = +localStorage.getItem('unicornWins') || 0;
    let heartWins = +localStorage.getItem('heartWins') || 0;
    let draws = +localStorage.getItem('draws') || 0;

    // New state for "Who Goes First"
    let whoGoesFirstSetting = localStorage.getItem('whoGoesFirstSetting') || 'player1'; // 'player1', 'random', 'loser'
    let lastWinner = null; // null, currentSymbols.player1, currentSymbols.player2
    let previousGameExists = false; // To handle "loser first" on the very first game

    // ======== AudioContext Management =========
    let audioCtx;
    function getAudioContext() {
        if (!audioCtx) {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.error("AudioContext not supported or could not be created.", e);
                soundEnabled = false; soundToggle.textContent = '🔇'; localStorage.setItem('soundDisabled', true); return null;
            }
        }
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume().catch(err => {
                console.error("Failed to resume AudioContext. Disabling sound.", err);
                soundEnabled = false; soundToggle.textContent = '🔇'; localStorage.setItem('soundDisabled', true);
            });
        }
        return audioCtx;
    }

    // Load theme preference
    const isDarkTheme = localStorage.getItem('darkTheme') === 'true';
    if (isDarkTheme) { document.body.classList.add('dark-theme'); themeToggle.textContent = '☀️'; }

    // Load sound preference
    const isSoundDisabled = localStorage.getItem('soundDisabled') === 'true';
    if (isSoundDisabled) { soundEnabled = false; soundToggle.textContent = '🔇'; }

    const winningCombos = [
        [0,1,2],[3,4,5],[6,7,8], [0,3,6],[1,4,7],[2,5,8], [0,4,8],[2,4,6]
    ];

    function setBoardClickable(clickable) {
        cells.forEach(cellNode => {
            if (clickable) {
                if (!board[cellNode.dataset.index]) { // Only enable empty cells
                    cellNode.classList.remove('disabled');
                }
            } else {
                cellNode.classList.add('disabled');
            }
        });
    }

    // ========= Inicialización =========
    function init(mode = vsCPU ? 'cpu' : 'pvp', diff = difficulty || 'medium') {
        removeConfetti();
        board = Array(9).fill(null);
        vsCPU = mode === 'cpu';
        difficulty = diff;

        let initialPlayer;
        switch (whoGoesFirstSetting) {
            case 'random':
                initialPlayer = Math.random() < 0.5 ? currentSymbols.player1 : currentSymbols.player2;
                break;
            case 'loser':
                if (!previousGameExists || lastWinner === null) { // First game ever, or last game was a draw/tie
                    initialPlayer = currentSymbols.player1; // Default to P1
                } else if (lastWinner === currentSymbols.player1) {
                    initialPlayer = currentSymbols.player2;
                } else { // lastWinner was currentSymbols.player2
                    initialPlayer = currentSymbols.player1;
                }
                break;
            case 'player1':
            default:
                initialPlayer = currentSymbols.player1;
                break;
        }
        currentPlayer = initialPlayer;
        gameActive = true;

        cells.forEach(c => {
            if (c && c.querySelector('span')) { c.querySelector('span').textContent = ''; }
            if (c) { c.classList.remove('rainbow', 'mark-animation'); } // Keep 'disabled' status managed by setBoardClickable
        });
        setBoardClickable(true); // Enable by default, then disable if CPU starts

        statusDiv.textContent = `Turno del ${getPlayerName(currentPlayer)}`;
        statusDiv.classList.add('highlight');
        setTimeout(() => statusDiv.classList.remove('highlight'), 300);

        updateModeButtons();
        difficultyDiv.style.display = vsCPU ? 'flex' : 'none';
        updateDifficultyButtons();
        updateWhoGoesFirstButtons(); // Ensure "who goes first" buttons are correctly highlighted

        const gameBoard = document.getElementById('game');
        gameBoard.style.transform = 'scale(0.95)';
        setTimeout(() => { gameBoard.style.transform = ''; }, 200);

        playSound('reset');

        if (vsCPU && currentPlayer === currentSymbols.player2 && gameActive) {
            setBoardClickable(false); // CPU is starting, make board unclickable
            setTimeout(() => {
                cpuMove();
                if (gameActive) { // Make board clickable after CPU's first move, if game not ended
                    setBoardClickable(true);
                }
            }, 700);
        }
    }

    function getPlayerName(symbol) {
        const player1Name = symbol === '🦄' ? 'Unicornio' : symbol === '🐱' ? 'Gatito' : symbol === '🌞' ? 'Sol' : 'Equis';
        const player2Name = symbol === '❤️' ? 'Corazón' : symbol === '🐶' ? 'Perrito' : symbol === '🌙' ? 'Luna' : 'Círculo';
        return symbol === currentSymbols.player1 ? `${symbol} ${player1Name}` : `${symbol} ${player2Name}`;
    }

    function updateModeButtons() {
        pvpBtn.classList.toggle('active', !vsCPU);
        cpuBtn.classList.toggle('active', vsCPU);
    }

    function updateDifficultyButtons() {
        easyBtn.classList.toggle('active', difficulty === 'easy');
        mediumBtn.classList.toggle('active', difficulty === 'medium');
        hardBtn.classList.toggle('active', difficulty === 'hard');
    }

    function updateWhoGoesFirstButtons() {
        player1StartsBtn.classList.toggle('active', whoGoesFirstSetting === 'player1');
        randomStartsBtn.classList.toggle('active', whoGoesFirstSetting === 'random');
        loserStartsBtn.classList.toggle('active', whoGoesFirstSetting === 'loser');
    }

    // ========= Lógica del juego =========
    function handleCellClick(e) {
        const cellElement = e.currentTarget;
        if (!cellElement || typeof cellElement.dataset === 'undefined') return;
        const idxStr = cellElement.dataset.index;
        if (typeof idxStr === 'undefined') return;
        const idx = +idxStr;
        if (isNaN(idx)) return;

        if (!gameActive || board[idx] !== null || cellElement.classList.contains('disabled')) return;

        makeMove(idx, currentPlayer);
        const winInfo = checkWin(currentPlayer);

        if (winInfo) return endGame(currentPlayer, winInfo);
        if (checkDraw()) return endDraw();

        switchPlayer();
        if (vsCPU && currentPlayer === currentSymbols.player2 && gameActive) {
            setBoardClickable(false); // Human just moved, now CPU's turn, disable board
            setTimeout(() => {
                cpuMove();
                if (gameActive) { // Re-enable board if game didn't end
                    setBoardClickable(true);
                }
            }, 700);
        }
    }

    function makeMove(idx, player) {
        board[idx] = player;
        const cell = cells[idx];
        if (!cell) return;
        const span = cell.querySelector('span');
        if (!span) return;
        span.textContent = player;
        cell.classList.add('disabled', 'mark-animation'); // Mark cell as used and disabled
        setTimeout(() => cell.classList.remove('mark-animation'), 300);
        playSound('move');
    }

    function cpuMove() {
        if (!gameActive) return; // Ensure game is active before CPU moves
        let idx;
        switch(difficulty) {
            case 'easy': idx = randomMove(); break;
            case 'medium': idx = Math.random() < 0.7 ? bestMove() : randomMove(); break;
            case 'hard': default: idx = bestMove(); break;
        }
        if (idx === undefined || idx === null || board[idx] !== null) { // Double check if cell is available
             // Fallback if bestMove/randomMove somehow failed or picked a taken cell
            idx = randomMove();
            if (idx === null) { // No moves left, should be a draw but handle defensively
                if(checkDraw()) endDraw();
                return;
            }
        }

        makeMove(idx, currentSymbols.player2);
        const winInfo = checkWin(currentSymbols.player2);
        if (winInfo) return endGame(currentSymbols.player2, winInfo);
        if (checkDraw()) return endDraw();
        switchPlayer(); // Switch back to human player
    }

    function randomMove() {
        const available = board.map((val, idx) => val === null ? idx : null).filter(val => val !== null);
        if (available.length === 0) return null;
        return available[Math.floor(Math.random() * available.length)];
    }

    function bestMove() { // Minimax implementation as before
        // Check if CPU can win in one move
        for (let i = 0; i < board.length; i++) {
            if (!board[i]) {
                board[i] = currentSymbols.player2;
                if (checkWin(currentSymbols.player2)) { board[i] = null; return i; }
                board[i] = null;
            }
        }
        // Check if player can win in one move (block)
        for (let i = 0; i < board.length; i++) {
            if (!board[i]) {
                board[i] = currentSymbols.player1;
                if (checkWin(currentSymbols.player1)) { board[i] = null; return i; }
                board[i] = null;
            }
        }
        // Minimax logic (simplified for brevity, use your existing robust one)
        let bestScore = -Infinity;
        let move;
        for (let i = 0; i < board.length; i++) {
            if (!board[i]) {
                board[i] = currentSymbols.player2;
                let score = minimax(board, 0, false);
                board[i] = null;
                if (score > bestScore) {
                    bestScore = score;
                    move = i;
                }
            }
        }
        return move !== undefined ? move : randomMove();
    }

    function minimax(currentBoard, depth, isMaximizing) {
        const cpuWin = checkWin(currentSymbols.player2, currentBoard);
        const playerWin = checkWin(currentSymbols.player1, currentBoard);
        if (cpuWin) return 10 - depth;
        if (playerWin) return depth - 10;
        if (checkDraw(currentBoard)) return 0;

        if (isMaximizing) {
            let bestScore = -Infinity;
            for (let i = 0; i < currentBoard.length; i++) {
                if (!currentBoard[i]) {
                    currentBoard[i] = currentSymbols.player2;
                    bestScore = Math.max(bestScore, minimax(currentBoard, depth + 1, false));
                    currentBoard[i] = null;
                }
            }
            return bestScore;
        } else {
            let bestScore = Infinity;
            for (let i = 0; i < currentBoard.length; i++) {
                if (!currentBoard[i]) {
                    currentBoard[i] = currentSymbols.player1;
                    bestScore = Math.min(bestScore, minimax(currentBoard, depth + 1, true));
                    currentBoard[i] = null;
                }
            }
            return bestScore;
        }
    }

    function checkWin(player, currentBoard = board) {
        for (const combo of winningCombos) {
            if (combo.every(index => currentBoard[index] === player)) return combo;
        }
        return null;
    }

    function checkDraw(currentBoard = board) { return currentBoard.every(cell => cell !== null); }

    function endGame(player, winningCells) {
        if (winningCells) winningCells.forEach(i => cells[i] && cells[i].classList.add('rainbow'));
        gameActive = false;
        statusDiv.textContent = `¡${getPlayerName(player)} ganó!`;
        statusDiv.classList.add('highlight');

        if (player === currentSymbols.player1) {
            unicornWins++; localStorage.setItem('unicornWins', unicornWins);
            lastWinner = currentSymbols.player1;
        } else {
            heartWins++; localStorage.setItem('heartWins', heartWins);
            lastWinner = currentSymbols.player2;
        }
        previousGameExists = true; // Mark that a game has been completed
        updateScoreboard();
        playSound('win');
        launchConfetti();
        setBoardClickable(false); // Disable board after game ends
    }

    function endDraw() {
        gameActive = false;
        statusDiv.textContent = '¡Empate!';
        statusDiv.classList.add('highlight');
        draws++; localStorage.setItem('draws', draws);
        lastWinner = null; // No winner in a draw
        previousGameExists = true; // Mark that a game has been completed
        updateScoreboard();
        playSound('draw');
        setBoardClickable(false); // Disable board after game ends
    }

    function switchPlayer() {
        currentPlayer = currentPlayer === currentSymbols.player1 ? currentSymbols.player2 : currentSymbols.player1;
        statusDiv.textContent = `Turno del ${getPlayerName(currentPlayer)}`;
        statusDiv.classList.add('highlight');
        setTimeout(() => statusDiv.classList.remove('highlight'), 300);
    }

    function updateScoreboard() {
        unicornSpan.textContent = unicornWins;
        heartSpan.textContent = heartWins;
        drawsSpan.textContent = draws;
    }

    function playSound(type) { /* ... Your existing playSound ... */
        if (!soundEnabled) return;
        const ctx = getAudioContext();
        if (!ctx || ctx.state === 'suspended') return;
        try {
            const o = ctx.createOscillator(); const g = ctx.createGain(); o.connect(g); g.connect(ctx.destination);
            let freq1=440, freq2=880, duration=0.2, gainVal=0.1, waveType='sine';
            switch(type) {
                case 'move': freq1=440; duration=0.2; gainVal=0.08; waveType='sine'; break;
                case 'win': freq1=600; freq2=900; let freq3=1200; duration=0.7; gainVal=0.12; waveType='triangle';
                    o.frequency.setValueAtTime(freq1, ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(freq2, ctx.currentTime + duration*0.33);
                    o.frequency.linearRampToValueAtTime(freq3, ctx.currentTime + duration*0.66);
                    break;
                case 'draw': freq1=330; freq2=220; duration=0.4; gainVal=0.1; waveType='square';
                    o.frequency.setValueAtTime(freq1, ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(freq2, ctx.currentTime + duration*0.5);
                    break;
                case 'reset': freq1=500; freq2=300; duration=0.25; gainVal=0.07; waveType='sine';
                    o.frequency.setValueAtTime(freq1, ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(freq2, ctx.currentTime + duration*0.5);
                    break;
                default: return;
            }
            o.type = waveType;
            if(type !== 'win' && type !== 'draw' && type !== 'reset') o.frequency.setValueAtTime(freq1, ctx.currentTime);
            g.gain.setValueAtTime(gainVal, ctx.currentTime);
            o.start();
            g.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + duration);
            o.stop(ctx.currentTime + duration);
        } catch (err) { console.error("Error playing sound:", type, err); }
    }

    function launchConfetti() { /* ... Your existing launchConfetti ... */
        const colors = ['#ff3860','#ffdd57','#17d1a2','#3e8ed0','#b86bff'];
        for (let i = 0; i < 120; i++) {
            const conf = document.createElement('div'); conf.className = 'confetti';
            conf.style.left = Math.random()*100+'vw'; conf.style.width=(Math.random()*8+4)+'px';
            conf.style.height=(Math.random()*12+6)+'px'; conf.style.background=colors[Math.floor(Math.random()*colors.length)];
            conf.style.transform=`rotate(${Math.random()*360}deg)`; conf.style.animationDelay=(Math.random()*0.5)+'s';
            conf.style.animationDuration=(Math.random()*2+2)+'s'; document.body.appendChild(conf);
            setTimeout(() => { if (conf && conf.parentNode) conf.parentNode.removeChild(conf); }, 3500);
        }
    }
    function removeConfetti() { document.querySelectorAll('.confetti').forEach(c => c.remove()); }

    function toggleTheme() {
        const isDark = document.body.classList.toggle('dark-theme');
        themeToggle.textContent = isDark ? '☀️' : '🌙'; localStorage.setItem('darkTheme', isDark); playSound('move');
    }
    function toggleSound() {
        soundEnabled = !soundEnabled; soundToggle.textContent = soundEnabled ? '🔊' : '🔇';
        localStorage.setItem('soundDisabled', !soundEnabled);
        if (soundEnabled) { const ctx = getAudioContext(); if (ctx && ctx.state === 'running') playSound('move'); else if (ctx && ctx.state === 'suspended') ctx.resume().then(() => playSound('move')).catch(err => console.error("Could not resume context", err));}
    }
    function changeSymbols() {
        currentSymbolIndex = (currentSymbolIndex + 1) % symbolSet.length;
        currentSymbols = symbolSet[currentSymbolIndex];
        // Determine who would have been current player with old symbols to maintain turn if game is active
        let oldPlayer1Symbol, oldPlayer2Symbol;
        if (currentSymbolIndex === 0) { // Wrapped around from last to first
            oldPlayer1Symbol = symbolSet[symbolSet.length - 1].player1;
            oldPlayer2Symbol = symbolSet[symbolSet.length - 1].player2;
        } else {
            oldPlayer1Symbol = symbolSet[currentSymbolIndex - 1].player1;
            oldPlayer2Symbol = symbolSet[currentSymbolIndex - 1].player2;
        }

        if (gameActive) {
            if (currentPlayer === oldPlayer1Symbol) {
                currentPlayer = currentSymbols.player1;
            } else if (currentPlayer === oldPlayer2Symbol) {
                currentPlayer = currentSymbols.player2;
            }
            statusDiv.textContent = `Turno del ${getPlayerName(currentPlayer)}`;
        } else {
             // If game not active, status reflects who *would* start next game (based on P1 default before init applies rules)
            statusDiv.textContent = `Turno del ${getPlayerName(currentSymbols.player1)}`;
        }

        const resultsDiv = document.getElementById('results');
        const childNodes = resultsDiv.childNodes;
        if (childNodes[0] && childNodes[0].nodeType === Node.TEXT_NODE) {
            childNodes[0].textContent = currentSymbols.player1 + ' ';
        }
        const dashIndex = Array.from(childNodes).findIndex(node => node.nodeType === Node.TEXT_NODE && node.textContent.includes('–'));
        if (dashIndex !== -1 && childNodes[dashIndex]) {
            childNodes[dashIndex].textContent = ' – ' + currentSymbols.player2 + ' ';
        }
        playSound('move');
        if (board.some(cell => cell !== null)) { // If board has moves, reset it
            init(); // init will use current vsCPU and difficulty settings
        } else { // If board is empty, just update display elements potentially affected by symbols (like status)
            if (!gameActive) { // If game was over and board is now clear for next round.
                init(); // Start a new game to apply new symbols and whoGoesFirst logic properly.
            }
        }
    }

    // ========= Event Listeners =========
    cells.forEach(c => c.addEventListener('click', handleCellClick));
    restartBtn.addEventListener('click', () => init()); // init will use current settings
    pvpBtn.addEventListener('click', () => { if (!vsCPU) return; init('pvp', difficulty); });
    cpuBtn.addEventListener('click', () => { if (vsCPU) return; init('cpu', difficulty); });

    easyBtn.addEventListener('click', () => { if (difficulty === 'easy') return; difficulty = 'easy'; updateDifficultyButtons(); playSound('move');});
    mediumBtn.addEventListener('click', () => { if (difficulty === 'medium') return; difficulty = 'medium'; updateDifficultyButtons(); playSound('move'); });
    hardBtn.addEventListener('click', () => { if (difficulty === 'hard') return; difficulty = 'hard'; updateDifficultyButtons(); playSound('move');});

    themeToggle.addEventListener('click', toggleTheme);
    soundToggle.addEventListener('click', toggleSound);
    changeSymbolsBtn.addEventListener('click', changeSymbols);

    // "Who Goes First" Button Listeners
    player1StartsBtn.addEventListener('click', () => {
        if (whoGoesFirstSetting === 'player1') return;
        whoGoesFirstSetting = 'player1';
        localStorage.setItem('whoGoesFirstSetting', whoGoesFirstSetting);
        updateWhoGoesFirstButtons();
        playSound('move');
        if (!gameActive) init(); // If no game active, restart to apply setting
    });
    randomStartsBtn.addEventListener('click', () => {
        if (whoGoesFirstSetting === 'random') return;
        whoGoesFirstSetting = 'random';
        localStorage.setItem('whoGoesFirstSetting', whoGoesFirstSetting);
        updateWhoGoesFirstButtons();
        playSound('move');
        if (!gameActive) init();
    });
    loserStartsBtn.addEventListener('click', () => {
        if (whoGoesFirstSetting === 'loser') return;
        whoGoesFirstSetting = 'loser';
        localStorage.setItem('whoGoesFirstSetting', whoGoesFirstSetting);
        updateWhoGoesFirstButtons();
        playSound('move');
        if (!gameActive) init();
    });


    cells.forEach(cell => {
        cell.setAttribute('tabindex', '0');
        cell.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); e.currentTarget.click(); }
        });
    });
    document.addEventListener('dblclick', function(e) { e.preventDefault(); }, { passive: false });

    // Initial setup calls
    updateScoreboard();
    // updateWhoGoesFirstButtons(); // Called within init
    init(); // Initial game setup
});
</script>
</body>
</html>